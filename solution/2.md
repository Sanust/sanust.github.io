# 0002 【模板】快速幂取余

## 题目描述

给你三个整数 $a,b,p$，求 $a^b \bmod p$。

## 输入格式

输入只有一行三个整数，分别代表 $a,b,p$。

## 输出格式

输出一行一个字符串 `a^b mod p=s`，其中 $a,b,p$ 分别为题目给定的值， $s$ 为运算结果。

## 输入样例

```
2 10 9
```

## 输出样例

```
2^10 mod 9=7
```

## 提示

**样例解释**

$2^{10} = 1024$，$1024 \bmod 9 = 7$。

**数据规模与约定**

对于 $100\%$ 的数据，保证 $0\le a,b < 2^{31}$，$a+b>0$，$2 \leq p \lt 2^{31}$。

# 题解 Solution

求 $a^b$ ，先从 $a$ 开始看起，自乘一次是 $a^2$，然后是$a^4$……，自乘$n$次是$a^{2n}$；其次$a^xa^y=a^{x+y}$。如果把$b$转成二进制，从右往左，它每一个$1$都代表着$1,2,4,8$……，即二进制的数码。

在函数运算开始前，我们要定义一个$base$，初始化为$a$，用于表示$a^{当前数码}$的结果，一个$ans$，初始化为$1$，用于记录答案。

如果拿到了一个指数$b$，例如$b=11$，在二进制下是$1011$。我们不断循环直到指数乘完了等于$0$，也就是运算结束，在循环中检查$b$在二进制下的末尾一位是否为$1$，如果是的，那就代表结果中存在$a^{当前数码}$，让$ans×=base$即可；如果不是，那就不做任何操作。

同时在循环内每循环一次就要让$b$的二进制结果向右移动一位，使下次访问$b$在二进制下的末尾一位的结果更新，并使$base$自乘，即变成$a^{下一个数码}$的结果。

总的来说，如果 $b$ 在二进制上的某一位是 $1$，我们就把答案乘上对应的 $a^{2^{n}}$。

取余操作中在加，乘运算中，先让两数分别取余并在运算完的结果后再取余的值和两数运算完的结果取余的值是相同的，可以有效防止超范围，效果和“先乘到最后，最后取余的效果”一样。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
ull n, m, q;
ull qpow(ull a, ull b, ull p)
{
    ull ans = 1, base = a;
    while (b)
    {
        if (b & 1)
            ans = (ans * base) % p;
        base = (base * base) % p, b >>= 1;
    }
    return ans;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin >> n >> m >> q;
    cout << n << "^" << m << " mod " << q << "=" << qpow(n, m, q);
    return 0;
}
```